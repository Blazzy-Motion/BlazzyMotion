using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Text;

namespace BlazzyMotion.SourceGen
{
    /// <summary>
    /// Incremental Source Generator that creates ModuleInitializer registration code
    /// for types decorated with [BzImage] attribute.
    /// </summary>
    [ExcludeFromCodeCoverage]
    [Generator]
    public class BzMappingGenerator : IIncrementalGenerator
    {
        // CONSTANTS

        private const string BzImageAttributeFullName = "BlazzyMotion.Core.Attributes.BzImageAttribute";
        private const string BzImageAttributeLegacyName = "BlazzyMotion.Carousel.Attributes.BzImageAttribute";
        private const string BzTitleAttributeFullName = "BlazzyMotion.Core.Attributes.BzTitleAttribute";
        private const string BzTitleAttributeLegacyName = "BlazzyMotion.Carousel.Attributes.BzTitleAttribute";
        private const string BzDescriptionAttributeFullName = "BlazzyMotion.Core.Attributes.BzDescriptionAttribute";
        private const string BzDescriptionAttributeLegacyName = "BlazzyMotion.Carousel.Attributes.BzDescriptionAttribute";
        private const string BzBentoItemAttributeFullName = "BlazzyMotion.Core.Attributes.BzBentoItemAttribute";

        // INITIALIZE

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // Register marker file
            context.RegisterPostInitializationOutput(ctx =>
            {
                ctx.AddSource("BzMappingGenerator.Marker.g.cs", SourceText.From(@"
// <auto-generated/>
namespace BlazzyMotion.SourceGen
{
    internal static class BzMappingGeneratorMarker
    {
        public const string Version = ""1.0.0"";
        public const string Pattern = ""ModuleInitializer"";
    }
}
", Encoding.UTF8));
            });

            // Create incremental pipeline
            var classDeclarations = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (syntaxNode, _) => IsSyntaxTargetForGeneration(syntaxNode),
                    transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
                .Where(static classInfo => classInfo is not null);

            var compilationAndClasses = context.CompilationProvider
                .Combine(classDeclarations.Collect());

            context.RegisterSourceOutput(
                compilationAndClasses,
                static (sourceContext, source) => Execute(source.Left, source.Right!, sourceContext));
        }

        // SYNTAX FILTER

        private static bool IsSyntaxTargetForGeneration(SyntaxNode syntaxNode)
        {
            if (syntaxNode is not ClassDeclarationSyntax classDeclaration)
                return false;

            return classDeclaration.Members
                .OfType<PropertyDeclarationSyntax>()
                .Any();
        }

        // SEMANTIC ANALYSIS

        private static MappingClassInfo? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
        {
            var classDeclaration = (ClassDeclarationSyntax)context.Node;
            var classSymbol = context.SemanticModel.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;

            if (classSymbol is null)
                return null;

            // Find properties with attributes
            var imageProperty = FindPropertyWithAttribute(classSymbol, BzImageAttributeFullName, BzImageAttributeLegacyName);
            var titleProperty = FindPropertyWithAttribute(classSymbol, BzTitleAttributeFullName, BzTitleAttributeLegacyName);
            var descriptionProperty = FindPropertyWithAttribute(classSymbol, BzDescriptionAttributeFullName, BzDescriptionAttributeLegacyName);

            // Find BzBentoItem attribute for layout info
            var bentoAttribute = FindBentoItemAttribute(classSymbol);
            var bentoLayout = ExtractBentoLayoutInfo(bentoAttribute);

            if (imageProperty is null)
                return null;

            if (imageProperty.DeclaredAccessibility != Accessibility.Public)
                return null;

            if (imageProperty.Type.SpecialType != SpecialType.System_String)
                return null;

            return new MappingClassInfo(
                Namespace: classSymbol.ContainingNamespace.ToDisplayString(),
                ClassName: classSymbol.Name,
                FullyQualifiedName: classSymbol.ToDisplayString(),
                ImageProperty: imageProperty.Name,
                TitleProperty: titleProperty?.Name,
                DescriptionProperty: descriptionProperty?.Name,
                BentoLayout: bentoLayout
            );
        }

        private static IPropertySymbol? FindPropertyWithAttribute(
            INamedTypeSymbol classSymbol,
            string attributeName,
            string legacyAttributeName)
        {
            foreach (var member in classSymbol.GetMembers())
            {
                if (member is not IPropertySymbol property)
                    continue;

                var hasAttribute = property.GetAttributes()
                    .Any(attr =>
                    {
                        var attrName = attr.AttributeClass?.ToDisplayString();
                        return attrName == attributeName || attrName == legacyAttributeName;
                    });

                if (hasAttribute)
                    return property;
            }

            var baseType = classSymbol.BaseType;
            if (baseType is not null && baseType.SpecialType != SpecialType.System_Object)
            {
                return FindPropertyWithAttribute(baseType, attributeName, legacyAttributeName);
            }

            return null;
        }

        private static AttributeData? FindBentoItemAttribute(INamedTypeSymbol classSymbol)
        {
            foreach (var member in classSymbol.GetMembers())
            {
                if (member is not IPropertySymbol property)
                    continue;

                var bentoAttribute = property.GetAttributes()
                    .FirstOrDefault(attr =>
                        attr.AttributeClass?.ToDisplayString() == BzBentoItemAttributeFullName);

                if (bentoAttribute is not null)
                    return bentoAttribute;
            }

            var baseType = classSymbol.BaseType;
            if (baseType is not null && baseType.SpecialType != SpecialType.System_Object)
            {
                return FindBentoItemAttribute(baseType);
            }

            return null;
        }

        private static BentoLayoutInfo? ExtractBentoLayoutInfo(AttributeData? attribute)
        {
            if (attribute is null)
                return null;

            int colSpan = 1;
            int rowSpan = 1;
            int order = 0;

            var constructorArgs = attribute.ConstructorArguments;
            if (constructorArgs.Length >= 1 && constructorArgs[0].Value is int col)
                colSpan = col;
            if (constructorArgs.Length >= 2 && constructorArgs[1].Value is int row)
                rowSpan = row;
            if (constructorArgs.Length >= 3 && constructorArgs[2].Value is int ord)
                order = ord;

            foreach (var namedArg in attribute.NamedArguments)
            {
                switch (namedArg.Key)
                {
                    case "ColSpan" when namedArg.Value.Value is int c:
                        colSpan = c;
                        break;
                    case "RowSpan" when namedArg.Value.Value is int r:
                        rowSpan = r;
                        break;
                    case "Order" when namedArg.Value.Value is int o:
                        order = o;
                        break;
                }
            }

            return new BentoLayoutInfo(colSpan, rowSpan, order);
        }

        // CODE GENERATION

        private static void Execute(
            Compilation compilation,
            ImmutableArray<MappingClassInfo?> classes,
            SourceProductionContext context)
        {
            if (classes.IsEmpty)
                return;

            foreach (var classInfo in classes.Distinct())
            {
                if (classInfo is null)
                    continue;

                var sourceCode = GenerateRegistrationClass(classInfo);
                var hintName = $"{classInfo.ClassName}.BzMapping.g.cs";

                context.AddSource(hintName, SourceText.From(sourceCode, Encoding.UTF8));
            }
        }

        private static string GenerateRegistrationClass(MappingClassInfo classInfo)
        {
            var sb = new StringBuilder();

            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("// Generated by BlazzyMotion.SourceGen.BzMappingGenerator v1.0.0");
            sb.AppendLine($"// Class: {classInfo.ClassName}");
            sb.AppendLine($"// Image Property: {classInfo.ImageProperty}");
            if (classInfo.TitleProperty != null)
                sb.AppendLine($"// Title Property: {classInfo.TitleProperty}");
            sb.AppendLine();
            sb.AppendLine("#nullable enable");
            sb.AppendLine();
            sb.AppendLine("using System.Runtime.CompilerServices;");
            sb.AppendLine("using BlazzyMotion.Core.Models;");
            sb.AppendLine("using BlazzyMotion.Core.Services;");
            sb.AppendLine();
            sb.AppendLine($"namespace {classInfo.Namespace}");
            sb.AppendLine("{");
            sb.AppendLine($"    internal static class BzMappingRegistration_{classInfo.ClassName}");
            sb.AppendLine("    {");
            sb.AppendLine("        [ModuleInitializer]");
            sb.AppendLine("        internal static void Register()");
            sb.AppendLine("        {");
            sb.AppendLine($"            BzRegistry.Register<{classInfo.ClassName}>(item => new BzItem");
            sb.AppendLine("            {");
            sb.AppendLine($"                ImageUrl = item.{classInfo.ImageProperty},");

            if (classInfo.TitleProperty != null)
                sb.AppendLine($"                Title = item.{classInfo.TitleProperty},");
            else
                sb.AppendLine("                Title = null,");

            if (classInfo.DescriptionProperty != null)
                sb.AppendLine($"                Description = item.{classInfo.DescriptionProperty},");
            else
                sb.AppendLine("                Description = null,");

            // Add Bento layout from [BzBentoItem] attribute
            if (classInfo.BentoLayout != null)
            {
                sb.AppendLine($"                ColSpan = {classInfo.BentoLayout.ColSpan},");
                sb.AppendLine($"                RowSpan = {classInfo.BentoLayout.RowSpan},");
                sb.AppendLine($"                Order = {classInfo.BentoLayout.Order},");
            }

            sb.AppendLine("                OriginalItem = item");
            sb.AppendLine("            });");
            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine("}");

            return sb.ToString();
        }

        // DATA CLASSES

        private sealed record MappingClassInfo(
            string Namespace,
            string ClassName,
            string FullyQualifiedName,
            string ImageProperty,
            string? TitleProperty,
            string? DescriptionProperty,
            BentoLayoutInfo? BentoLayout = null
        );

        private sealed record BentoLayoutInfo(
            int ColSpan,
            int RowSpan,
            int Order
        );
    }
}
