using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Text;

namespace BlazzyMotion.SourceGen
{
    /// <summary>
    /// Incremental Source Generator that creates ModuleInitializer registration code
    /// for types decorated with [BzImage] attribute.
    /// </summary>
    /// <remarks>
    /// <para>
    /// This generator runs at compile-time and produces registration code that
    /// automatically registers type mappers with <see cref="BzRegistry"/> at
    /// application startup using the [ModuleInitializer] attribute.
    /// </para>
    /// <para>
    /// <strong>Generated Code Pattern:</strong>
    /// <code>
    /// internal static class BzMappingRegistration_{ClassName}
    /// {
    ///     [ModuleInitializer]
    ///     internal static void Register()
    ///     {
    ///         BzRegistry.Register&lt;{ClassName}&gt;(item => new BzItem
    ///         {
    ///             ImageUrl = item.{ImageProperty},
    ///             Title = item.{TitleProperty},
    ///             OriginalItem = item
    ///         });
    ///     }
    /// }
    /// </code>
    /// </para>
    /// <para>
    /// <strong>Performance Benefits:</strong>
    /// <list type="bullet">
    /// <item>Zero reflection at runtime</item>
    /// <item>Registration happens once at app startup</item>
    /// <item>Compiled mapping functions (fastest possible)</item>
    /// </list>
    /// </para>
    /// </remarks>
    [ExcludeFromCodeCoverage]
    [Generator]
    public class BzMappingGenerator : IIncrementalGenerator
    {
        // CONSTANTS

        /// <summary>
        /// Fully-qualified name of the BzImage attribute (Core namespace).
        /// </summary>
        private const string BzImageAttributeFullName = "BlazzyMotion.Core.Attributes.BzImageAttribute";

        /// <summary>
        /// Fully-qualified name of the BzImage attribute (Carousel namespace - backward compat).
        /// </summary>
        private const string BzImageAttributeLegacyName = "BlazzyMotion.Carousel.Attributes.BzImageAttribute";

        /// <summary>
        /// Fully-qualified name of the BzTitle attribute (Core namespace).
        /// </summary>
        private const string BzTitleAttributeFullName = "BlazzyMotion.Core.Attributes.BzTitleAttribute";

        /// <summary>
        /// Fully-qualified name of the BzTitle attribute (Carousel namespace - backward compat).
        /// </summary>
        private const string BzTitleAttributeLegacyName = "BlazzyMotion.Carousel.Attributes.BzTitleAttribute";

        /// <summary>
        /// Fully-qualified name of the BzDescription attribute (Core namespace).
        /// </summary>
        private const string BzDescriptionAttributeFullName = "BlazzyMotion.Core.Attributes.BzDescriptionAttribute";

        /// <summary>
        /// Fully-qualified name of the BzDescription attribute (Carousel namespace - backward compat).
        /// </summary>
        private const string BzDescriptionAttributeLegacyName = "BlazzyMotion.Carousel.Attributes.BzDescriptionAttribute";

        // INITIALIZE

        /// <summary>
        /// Initializes the incremental generator pipeline.
        /// </summary>
        /// <param name="context">Generator initialization context</param>
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {

            // STEP 1: Register marker file for debugging

            context.RegisterPostInitializationOutput(ctx =>
            {
                ctx.AddSource("BzMappingGenerator.Marker.g.cs", SourceText.From(@"
// <auto-generated/>
// This file is generated by BlazzyMotion.SourceGen.BzMappingGenerator
// to verify the generator is running correctly.

namespace BlazzyMotion.SourceGen
{
    /// <summary>
    /// Marker class to verify BzMappingGenerator execution.
    /// </summary>
    internal static class BzMappingGeneratorMarker
    {
        /// <summary>
        /// Generator version.
        /// </summary>
        public const string Version = ""1.0.0"";

        /// <summary>
        /// Indicates this generator uses ModuleInitializer pattern.
        /// </summary>
        public const string Pattern = ""ModuleInitializer"";
    }
}
", Encoding.UTF8));
            });


            // STEP 2: Create incremental pipeline

            var classDeclarations = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (syntaxNode, _) => IsSyntaxTargetForGeneration(syntaxNode),
                    transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
                .Where(static classInfo => classInfo is not null);


            // STEP 3: Combine with compilation

            var compilationAndClasses = context.CompilationProvider
                .Combine(classDeclarations.Collect());


            // STEP 4: Register source generation

            context.RegisterSourceOutput(
                compilationAndClasses,
                static (sourceContext, source) => Execute(source.Left, source.Right!, sourceContext));
        }

        // SYNTAX FILTER

        /// <summary>
        /// Performs quick syntax-level check to filter candidate nodes.
        /// </summary>
        private static bool IsSyntaxTargetForGeneration(SyntaxNode syntaxNode)
        {
            if (syntaxNode is not ClassDeclarationSyntax classDeclaration)
                return false;

            // Quick check: Does the class have any properties?
            return classDeclaration.Members
                .OfType<PropertyDeclarationSyntax>()
                .Any();
        }

        // SEMANTIC ANALYSIS

        /// <summary>
        /// Performs detailed semantic analysis on candidate classes.
        /// </summary>
        private static MappingClassInfo? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
        {
            var classDeclaration = (ClassDeclarationSyntax)context.Node;
            var classSymbol = context.SemanticModel.GetDeclaredSymbol(classDeclaration) as INamedTypeSymbol;

            if (classSymbol is null)
                return null;

            // Find properties with our attributes (supports both Core and legacy namespaces)
            var imageProperty = FindPropertyWithAttribute(classSymbol, BzImageAttributeFullName, BzImageAttributeLegacyName);
            var titleProperty = FindPropertyWithAttribute(classSymbol, BzTitleAttributeFullName, BzTitleAttributeLegacyName);
            var descriptionProperty = FindPropertyWithAttribute(classSymbol, BzDescriptionAttributeFullName, BzDescriptionAttributeLegacyName);

            // If no [BzImage] found, skip this class
            if (imageProperty is null)
                return null;

            // Validate: Must be public string property
            if (imageProperty.DeclaredAccessibility != Accessibility.Public)
                return null;

            if (imageProperty.Type.SpecialType != SpecialType.System_String)
                return null;

            return new MappingClassInfo(
                Namespace: classSymbol.ContainingNamespace.ToDisplayString(),
                ClassName: classSymbol.Name,
                FullyQualifiedName: classSymbol.ToDisplayString(),
                ImageProperty: imageProperty.Name,
                TitleProperty: titleProperty?.Name,
                DescriptionProperty: descriptionProperty?.Name
            );
        }

        /// <summary>
        /// Finds a property decorated with one of the specified attributes.
        /// </summary>
        private static IPropertySymbol? FindPropertyWithAttribute(
            INamedTypeSymbol classSymbol,
            string attributeName,
            string legacyAttributeName)
        {
            // Search current class
            foreach (var member in classSymbol.GetMembers())
            {
                if (member is not IPropertySymbol property)
                    continue;

                var hasAttribute = property.GetAttributes()
                    .Any(attr =>
                    {
                        var attrName = attr.AttributeClass?.ToDisplayString();
                        return attrName == attributeName || attrName == legacyAttributeName;
                    });

                if (hasAttribute)
                    return property;
            }

            // Check base class
            var baseType = classSymbol.BaseType;
            if (baseType is not null && baseType.SpecialType != SpecialType.System_Object)
            {
                return FindPropertyWithAttribute(baseType, attributeName, legacyAttributeName);
            }

            return null;
        }

        // CODE GENERATION

        /// <summary>
        /// Generates source code for all classes with [BzImage] attribute.
        /// </summary>
        private static void Execute(
            Compilation compilation,
            ImmutableArray<MappingClassInfo?> classes,
            SourceProductionContext context)
        {
            if (classes.IsEmpty)
                return;

            foreach (var classInfo in classes.Distinct())
            {
                if (classInfo is null)
                    continue;

                var sourceCode = GenerateRegistrationClass(classInfo);
                var hintName = $"{classInfo.ClassName}.BzMapping.g.cs";

                context.AddSource(hintName, SourceText.From(sourceCode, Encoding.UTF8));
            }
        }

        /// <summary>
        /// Generates the ModuleInitializer registration class.
        /// </summary>
        private static string GenerateRegistrationClass(MappingClassInfo classInfo)
        {
            var sb = new StringBuilder();


            // FILE HEADER

            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("// Generated by BlazzyMotion.SourceGen.BzMappingGenerator v1.0.0");
            sb.AppendLine($"// Class: {classInfo.ClassName}");
            sb.AppendLine($"// Image Property: {classInfo.ImageProperty}");
            if (classInfo.TitleProperty != null)
                sb.AppendLine($"// Title Property: {classInfo.TitleProperty}");
            if (classInfo.DescriptionProperty != null)
                sb.AppendLine($"// Description Property: {classInfo.DescriptionProperty}");
            sb.AppendLine();
            sb.AppendLine("#nullable enable");
            sb.AppendLine();


            // USING STATEMENTS

            sb.AppendLine("using System.Runtime.CompilerServices;");
            sb.AppendLine("using BlazzyMotion.Core.Models;");
            sb.AppendLine("using BlazzyMotion.Core.Services;");
            sb.AppendLine();


            // NAMESPACE

            sb.AppendLine($"namespace {classInfo.Namespace}");
            sb.AppendLine("{");


            // CLASS XML DOCUMENTATION

            sb.AppendLine("    /// <summary>");
            sb.AppendLine($"    /// Auto-generated BzRegistry registration for <see cref=\"{classInfo.ClassName}\"/>.");
            sb.AppendLine("    /// </summary>");
            sb.AppendLine("    /// <remarks>");
            sb.AppendLine("    /// <para>");
            sb.AppendLine("    /// This class is automatically generated by BlazzyMotion.SourceGen");
            sb.AppendLine("    /// and registers a mapping function with BzRegistry at application startup.");
            sb.AppendLine("    /// </para>");
            sb.AppendLine("    /// <para>");
            sb.AppendLine("    /// The [ModuleInitializer] attribute ensures registration happens automatically");
            sb.AppendLine("    /// before any user code runs, with zero configuration required.");
            sb.AppendLine("    /// </para>");
            sb.AppendLine("    /// </remarks>");


            // CLASS DECLARATION

            sb.AppendLine($"    internal static class BzMappingRegistration_{classInfo.ClassName}");
            sb.AppendLine("    {");


            // METHOD XML DOCUMENTATION

            sb.AppendLine("        /// <summary>");
            sb.AppendLine($"        /// Registers the mapping function for <see cref=\"{classInfo.ClassName}\"/> with BzRegistry.");
            sb.AppendLine("        /// </summary>");
            sb.AppendLine("        /// <remarks>");
            sb.AppendLine("        /// <para>");
            sb.AppendLine("        /// This method is called automatically at application startup by the runtime");
            sb.AppendLine("        /// due to the [ModuleInitializer] attribute. No manual invocation is required.");
            sb.AppendLine("        /// </para>");
            sb.AppendLine("        /// <para>");
            sb.AppendLine("        /// <strong>Mapping:</strong>");
            sb.AppendLine("        /// <list type=\"bullet\">");
            sb.AppendLine($"        /// <item><c>{classInfo.ImageProperty}</c> → <c>BzItem.ImageUrl</c></item>");
            if (classInfo.TitleProperty != null)
                sb.AppendLine($"        /// <item><c>{classInfo.TitleProperty}</c> → <c>BzItem.Title</c></item>");
            if (classInfo.DescriptionProperty != null)
                sb.AppendLine($"        /// <item><c>{classInfo.DescriptionProperty}</c> → <c>BzItem.Description</c></item>");
            sb.AppendLine("        /// </list>");
            sb.AppendLine("        /// </para>");
            sb.AppendLine("        /// </remarks>");


            // METHOD WITH [ModuleInitializer]

            sb.AppendLine("        [ModuleInitializer]");
            sb.AppendLine("        internal static void Register()");
            sb.AppendLine("        {");
            sb.AppendLine($"            BzRegistry.Register<{classInfo.ClassName}>(item => new BzItem");
            sb.AppendLine("            {");
            sb.AppendLine($"                ImageUrl = item.{classInfo.ImageProperty},");

            if (classInfo.TitleProperty != null)
                sb.AppendLine($"                Title = item.{classInfo.TitleProperty},");
            else
                sb.AppendLine("                Title = null,");

            if (classInfo.DescriptionProperty != null)
                sb.AppendLine($"                Description = item.{classInfo.DescriptionProperty},");
            else
                sb.AppendLine("                Description = null,");

            sb.AppendLine("                OriginalItem = item");
            sb.AppendLine("            });");
            sb.AppendLine("        }");


            // CLOSE CLASS

            sb.AppendLine("    }");


            // CLOSE NAMESPACE

            sb.AppendLine("}");

            return sb.ToString();
        }


        // DATA CLASSES


        /// <summary>
        /// Data class holding information about a class that needs mapping registration.
        /// </summary>
        private sealed record MappingClassInfo(
            string Namespace,
            string ClassName,
            string FullyQualifiedName,
            string ImageProperty,
            string? TitleProperty,
            string? DescriptionProperty
        );
    }
}